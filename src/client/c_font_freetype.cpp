#include <c_font.h>

#include <c_graphics.h>

#include <u_assert.h>
#include <u_structs.h>

#ifdef USE_FONT_SYSTEM_FREETYPE

#include <ft2build.h>
#include <freetype/freetype.h>
#include <freetype/ftstroke.h>

#include <vector>
#include <map>

// API Reference:
// http://freetype.sourceforge.net/freetype2/docs/reference/ft2-index.html

// Tutorials:
// http://freetype.sourceforge.net/freetype2/docs/tutorial/step1.html
// http://freetype.sourceforge.net/freetype2/docs/tutorial/step2.html
// http://freetype.sourceforge.net/freetype2/docs/tutorial/step3.html
// Step2 shows a graphical breakdown of glyph metrics

// Much code borrowed from Erik Möller's coloured glyph w/ outline example
// http://freetype.sourceforge.net/freetype2/docs/tutorial/example2.cpp

// A horizontal pixel span generated by the FreeType renderer
struct Span
{
  Span( int32_t i_iX, int32_t i_iY, int32_t i_iWidth, int32_t i_iCoverage )
    : m_iX( i_iX )
    , m_iY( i_iY )
    , m_iWidth( i_iWidth )
    , m_iCoverage( i_iCoverage )
  {}

  int32_t m_iX{ 0 };
  int32_t m_iY{ 0 };
  int32_t m_iWidth{ 0 };
  int32_t m_iCoverage{ 0 };
};

typedef std::vector<Span> Spans;

FT_Library g_pcLibrary{ nullptr };


// Each time the renderer calls us back we just push another span entry on our list
void RasterCallback( const int32_t i_iY, const int32_t i_iCount, const FT_Span* const i_pcSpans,
                     void* const i_pcUserData )
{
  Spans* pcSpans{ (Spans*)i_pcUserData };
  for( int32_t i = 0; i < i_iCount; ++i )
  {
    pcSpans->push_back( Span( i_pcSpans[i].x, i_iY, i_pcSpans[i].len, i_pcSpans[i].coverage ) );
  }
}


// Set up the raster parameters and render the outline
void RenderSpans( FT_Library& io_rcLibrary, FT_Outline* const i_pcOutline, Spans* io_pcSpans )
{
  FT_Raster_Params cParams;
  memset( &cParams, 0, sizeof( cParams ) );
  cParams.flags = FT_RASTER_FLAG_AA | FT_RASTER_FLAG_DIRECT;
  cParams.gray_spans = RasterCallback;
  cParams.user = io_pcSpans;

  FT_Outline_Render( io_rcLibrary, i_pcOutline, &cParams );
}


int32_t rumFont::CreateGlyph( uint32_t i_uiCodePoint )
{
  if( !m_pcFaceData )
  {
    return RESULT_FAILED;
  }

  int32_t eResult{ RESULT_FAILED };

  static_assert( sizeof( FT_ULong ) == sizeof( uint32_t ) );
  const FT_ULong uiCharCode{ static_cast<FT_ULong>( i_uiCodePoint ) };

  const FT_Face pcFace{ reinterpret_cast<FT_Face>( m_pcFaceData ) };
  FT_UInt uiIndex{ FT_Get_Char_Index( pcFace, uiCharCode ) };
  if( FT_Load_Glyph( pcFace, uiIndex, FT_LOAD_DEFAULT/*FT_LOAD_NO_BITMAP*/ ) == 0 )
  {
    Spans cOutlineSpans;
    Spans cSpans;
    FT_Stroker pcStroker{ nullptr };

    // Render the basic glyph to a span list
    // TODO - This seems to only work with True Type Fonts
    RenderSpans( g_pcLibrary, &pcFace->glyph->outline, &cSpans );

    if( m_cAttributes.m_bOutlined )
    {
      // Need an outline for this to work.
      if( pcFace->glyph->format == FT_GLYPH_FORMAT_OUTLINE )
      {
        FT_Stroker_New( g_pcLibrary, &pcStroker );
        FT_Stroker_Set( pcStroker,
                        m_cAttributes.m_iOutlinePixelWidth * 64,
                        FT_STROKER_LINECAP_ROUND,  //FT_STROKER_LINECAP_SQUARE, FT_STROKER_LINECAP_BUTT
                        FT_STROKER_LINEJOIN_ROUND,
                        0 );
      }
      else
      {
        // Cancel outlined
        // TODO: might want to notify user of this
        m_cAttributes.m_bOutlined = false;
      }
    }

    FT_Glyph pcGlyph{ nullptr };
    if( FT_Get_Glyph( pcFace->glyph, &pcGlyph ) == 0 )
    {
      int32_t iGlyphWidth{ pcFace->glyph->metrics.width >> 6 };
      int32_t iGlyphHeight{ pcFace->glyph->metrics.height >> 6 };
      const int32_t iGlyphAscent{ pcFace->glyph->metrics.horiBearingY >> 6 };
      const int32_t iGlyphAdvance{ pcFace->glyph->advance.x >> 6 };

      if( m_cAttributes.m_bOutlined )
      {
        FT_Glyph_StrokeBorder( &pcGlyph, pcStroker, 0, 1 );

        // Again, this needs to be an outline to work
        if( pcGlyph->format == FT_GLYPH_FORMAT_OUTLINE )
        {
          // Render the outline spans to the span list
          FT_Outline* pcOutline{ &reinterpret_cast<FT_OutlineGlyph>( pcGlyph )->outline };
          RenderSpans( g_pcLibrary, pcOutline, &cOutlineSpans );
        }

        FT_Stroker_Done( pcStroker );
      }

      // Clean up afterwards.
      FT_Done_Glyph( pcGlyph );

      // Now we need to put it all together
      if( !cSpans.empty() )
      {
        rumPoint cMin;
        rumPoint cMax;

        // Determine the bounding rect
        if( m_cAttributes.m_bOutlined )
        {
          for( const auto& rcSpan : cOutlineSpans )
          {
            cMin.m_iX = std::min( cMin.m_iX, rcSpan.m_iX );
            cMin.m_iY = std::min( cMin.m_iY, rcSpan.m_iY );
            cMax.m_iX = std::max( cMax.m_iX, rcSpan.m_iX );
            cMax.m_iY = std::max( cMax.m_iY, rcSpan.m_iY );
          }
        }
        else
        {
          for( const auto& rcSpan : cSpans )
          {
            cMin.m_iX = std::min( cMin.m_iX, rcSpan.m_iX );
            cMin.m_iY = std::min( cMin.m_iY, rcSpan.m_iY );
            cMax.m_iX = std::max( cMax.m_iX, rcSpan.m_iX );
            cMax.m_iY = std::max( cMax.m_iY, rcSpan.m_iY );
          }
        }

        const rumRectangle cRect( cMin, cMax );

        // Get some metrics of our image.
        iGlyphWidth = cRect.GetWidth();
        iGlyphHeight = cRect.GetHeight();
        const int32_t iImgSize{ iGlyphWidth * iGlyphHeight };

        // Create the selected background color, but set it to total transparency
        rumColor cBackgroundColor( m_cAttributes.m_cBackgroundColor );
        cBackgroundColor.SetAlpha( 0 );

        // Allocate data for our image and clear it out to the background color
        rumColor* pcColor{ new rumColor[iImgSize] };
        memset( pcColor, cBackgroundColor.GetRGBA(), sizeof(rumColor) * iImgSize );

        int32_t iOffset{ 0 };

        // Loop over the outline spans and just draw them into the image
        if( m_cAttributes.m_bOutlined )
        {
          for( const auto& iter : cOutlineSpans )
          {
            for( int32_t i = 0; i < iter.m_iWidth; ++i )
            {
              iOffset = ( ( iGlyphHeight - 1 - ( iter.m_iY - cRect.m_cPoint1.m_iY ) ) *
                          iGlyphWidth + iter.m_iX - cRect.m_cPoint1.m_iX + i );
              rumAssert( iOffset >= 0 && iOffset < iImgSize );

              rumColor& rcDestColor{ pcColor[iOffset] };
              rcDestColor.SetRed(   m_cAttributes.m_cOutlineColor.GetRed() );
              rcDestColor.SetGreen( m_cAttributes.m_cOutlineColor.GetGreen() );
              rcDestColor.SetBlue(  m_cAttributes.m_cOutlineColor.GetBlue() );
              rcDestColor.SetAlpha( iter.m_iCoverage );
            }
          }
        }

        rumColor rcSourceColor( m_cAttributes.m_cFaceColor );

        // Then loop freetype/ftbbox.hp over the regular glyph spans and blend them into the image
        for( const auto& iter : cSpans )
        {
          for( int32_t i = 0; i < iter.m_iWidth; ++i )
          {
            iOffset = ( ( iGlyphHeight - 1 - ( iter.m_iY - cRect.m_cPoint1.m_iY ) ) *
                        iGlyphWidth + iter.m_iX - cRect.m_cPoint1.m_iX + i );
            rumAssert( iOffset >= 0 && iOffset < iImgSize );

            rumColor& rcDestColor{ pcColor[iOffset] };
            rcSourceColor.SetAlpha( iter.m_iCoverage );
            if( m_cAttributes.m_bAntialias )
            {
              rcDestColor.SetRed(   (uint32_t)( rcDestColor.GetRed() +
                                        ( ( rcSourceColor.GetRed() - rcDestColor.GetRed() ) *
                                          rcSourceColor.GetAlpha() ) / 255.0f ) );
              rcDestColor.SetGreen( (uint32_t)( rcDestColor.GetGreen() +
                                        ( ( rcSourceColor.GetGreen() - rcDestColor.GetGreen() ) *
                                          rcSourceColor.GetAlpha() ) / 255.0f ) );
              rcDestColor.SetBlue(  (uint32_t)( rcDestColor.GetBlue() +
                                        ( ( rcSourceColor.GetBlue() - rcDestColor.GetBlue() ) *
                                          rcSourceColor.GetAlpha() ) / 255.0f ) );
              if( m_cAttributes.m_bBlendFace )
              {
                // The face and edges with blend with the target surface
                rcDestColor.SetAlpha( std::min( (uint32_t)255, rcDestColor.GetAlpha() + rcSourceColor.GetAlpha() ) );
              }
              else
              {
                // The face will not be blended with the target surface
                rcDestColor.SetAlpha( 255 );
              }
            }
            else
            {
              // Monochrome, no alpha-blending
              rcDestColor.SetRed(   rcSourceColor.GetRed() );
              rcDestColor.SetGreen( rcSourceColor.GetGreen() );
              rcDestColor.SetBlue(  rcSourceColor.GetBlue() );
              rcDestColor.SetAlpha( 255 );
            }
          }
        }

        eResult = AddGlyph( i_uiCodePoint, pcColor, iGlyphWidth, iGlyphHeight, iGlyphAdvance, iGlyphAscent );

        delete[] pcColor;
      }
      else
      {
        iGlyphWidth = iGlyphAdvance;
        const int32_t iImgSize{ iGlyphWidth * iGlyphHeight };

        // No image information for this glyph - possibly just a space. Create the selected background color, but set
        // it to total transparency
        rumColor cBackgroundColor( m_cAttributes.m_cBackgroundColor );
        cBackgroundColor.SetAlpha( 0 );

        // Allocate data for our image and clear it out to the background color
        rumColor* pcColor{ new rumColor[iImgSize] };
        memset( pcColor, cBackgroundColor.GetRGBA(), sizeof( rumColor ) * iImgSize );

        eResult = AddGlyph( i_uiCodePoint, pcColor, iGlyphWidth, iGlyphHeight, iGlyphAdvance, iGlyphAscent );

        delete[] pcColor;
      }
    }
  }

  return eResult;
}


// static
int32_t rumFont::InitApp()
{
  RUM_COUT( "Starting FreeType " << FREETYPE_MAJOR << "." << FREETYPE_MINOR << "." << FREETYPE_PATCH << "."
            " font handler\n" );

  return FT_Init_FreeType( &g_pcLibrary );

  /*
  FT_Error result;

  // Loading a monochrome glyph image into the slot:
  result = FT_Load_Glyph( face, glyph_index, FT_LOAD_RENDER | FT_LOAD_MONOCHROME );

  FT_Bitmap copy;
  FT_Bitmap_New(&copy);
  FT_Bitmap_Copy(library, &(face->glyph->bitmap), &copy);
  FT_Bitmap_Convert( library, &copy, &(face->glyph->bitmap), 8);
  FT_Bitmap_Done(library, &copy);
  */
}


// Static
// Create a font from the specified file object
bool rumFont::CreateApp( const std::string& i_strFile, const std::string& i_strKey,
                         const rumFontAttributes& i_rcFontAttributes )
{
  // Create a new FontObject
  rumFont* pcFont{ new rumFont() };
  if( !pcFont )
  {
    return false;
  }

  bool bCreated{ false };

  // Copy the attributes
  pcFont->m_cAttributes = i_rcFontAttributes;

  FT_Face pcFace{ nullptr };
  FT_Error eResult{ FT_New_Face( g_pcLibrary, i_strFile.c_str(), i_rcFontAttributes.m_iFaceIndex, &pcFace ) };
  if( RESULT_SUCCESS == eResult )
  {
    // Ensure a unicode characater map is loaded
    FT_Select_Charmap( pcFace, FT_ENCODING_UNICODE );

    pcFont->m_pcFaceData = reinterpret_cast<void*>( pcFace );
    // Alternative font size set
    /*FT_Set_Char_Size( face,
                        0,     // char_width in 1/64th of points
                        16*64, // char_height in 1/64th of points
                        300,   // horizontal device resolution
                        300 ); // vertical device resolution

        std::cout << "Font:     " << pcFont->face->family_name << std::endl;
        std::cout << "Style:    " << pcFont->face->style_name << std::endl;
        std::cout << "Faces:    " << pcFont->face->num_faces << std::endl;
        std::cout << "Charmaps: " << pcFont->face->num_charmaps << std::endl;
        std::cout << "Glyphs:   " << pcFont->face->num_glyphs << std::endl;
        if ( pcFont->face->num_fixed_sizes > 0 )
        {
            std::cout << "Fixed:    " << pcFont->face->num_fixed_sizes << std::endl;
            for( int32_t i = 0; i < pcFont->face->num_fixed_sizes; ++i )
            {
                FT_Bitmap_Size *pcSize = pcFont->face->available_sizes;
                pcSize += sizeof( FT_Bitmap_Size* ) * i;
                assert( pcSize );
                std::cout << pcSize->height << " ";
            }
            std::cout << std::endl;
        }
        std::cout << std::endl;
    */

    if( pcFace->num_fixed_sizes > 0 )
    {
      // The font contains bitmap strikes
      eResult = FT_Select_Size( pcFace, 0 );
    }
    else
    {
      eResult = FT_Set_Pixel_Sizes( pcFace, 0, i_rcFontAttributes.m_uiPixelHeight );
    }

    const int32_t iAscent{ ( pcFace->size->metrics.ascender >> 6 ) };
    const int32_t iDescent{ ( pcFace->size->metrics.descender >> 6 ) };

    // This seems to give better results than metrics.height
    const int32_t iHeight{ iAscent + abs( iDescent ) };

    pcFont->m_cAttributes.m_iAscent = iAscent;
    pcFont->m_cAttributes.m_iDescent = iDescent;
    pcFont->m_cAttributes.m_uiPixelHeight = iHeight;

    /*cout << "Font height requested: " << fp.m_uiPixelHeight << endl;
    cout << "Actual font height:    " << height << endl;
    cout << "Ascender:  " << ascent << endl;
    cout << "Descender: " << descent << endl;*/

    // Todo - try to guarantee font height?

    if( iHeight > 0 )
    {
      // Add the font to the font manager
      bCreated = Manage( pcFont, i_strKey );
    }
  }
  else
  {
    // The font file could not be opened or read, or it is simply broken
    if( FT_Err_Unknown_File_Format == eResult )
    {
      // The font file could be opened and read, but it appears that its font format is unsupported
      rumAssert( false );
    }
  }

  if( !bCreated )
  {
    delete pcFont;
    pcFont = nullptr;
  }

  return true;
}


void rumFont::ReleaseApp()
{
  FT_Face pcFace{ reinterpret_cast<FT_Face>( m_pcFaceData ) };
  FT_Done_Face( pcFace );
  m_pcFaceData = nullptr;
}


// static
void rumFont::ShutdownApp()
{
  // Clean up the library
  FT_Done_FreeType( g_pcLibrary );
}

#endif // USE_FONT_SYSTEM_FREETYPE
